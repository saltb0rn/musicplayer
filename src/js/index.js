/*
  This file is generated by Emacs.
*/
import "../css/index.css";
import Mustache from "mustache";
import "lazysizes";
import { storageAvailable, MusicManager } from "./mark";
import { MusicPlayer } from "./player";
import { isScrollable, throttle, getScrollbarWidth } from "./misc";

let musicHost = 'http://api.darksalt.me/musicplayer',
    // getData = (element, attr) => element.dataset[attr];
    lastMusicId = 0,
    getItem = (element, attr) => element.attributes.getNamedItem(attr).value;

// 音乐播放器上下文
class ExtendedMusicPlayer extends MusicPlayer {

    firstMusicNode = null
    currentMusicNode = null;
    prevMusicNode = null;

    select(music) {
        if (this.audioCtx) this.audioCtx.close();
        this.audio = new Audio();
        this.audio.crossOrigin = "anonymous";
        this.audio.src = music.file;
        this.audio.load();
        this.currentMusicNode = document.querySelector(`li.song[data-id=${CSS.escape(music.id)}]`);
        if (!this.currentMusicNode.classList.add('active'))
            this.currentMusicNode.classList.add('active');
        if (this.prevMusicNode)
            this.prevMusicNode.classList.remove('active');
        if (!this.firstMusicId) {
            let playlist = document.getElementById('music-content');
            this.firstMusicNode = playlist.children[0];
        }

        this.audio.addEventListener('loadedmetadata', function(event) {
            var musicEnd = document.querySelector('#music-end');
            var progressControl = document.querySelector('input[name=progress]');
            let date = new Date(null);
            date.setSeconds(this.duration);
            musicEnd.innerText = date.toISOString().substr(14,  5);
            progressControl.max = this.duration;
            progressControl.value = 0;
        }, false);

        this.audio.addEventListener('timeupdate', (function(event) {
            var progressControl = document.querySelector('input[name=progress]');
            progressControl.value = this.audio.currentTime;
        }).bind(this));

        this.audio.addEventListener('ended', (function(event) {
            this.next();
        }).bind(this), false);

        this.audioCtx = new (window.AudioContext || window.webkitAudioContext);
        this.track = this.audioCtx.createMediaElementSource(this.audio);
        this.gainNode = this.audioCtx.createGain();
        this.track.connect(this.gainNode).connect(this.audioCtx.destination);

        // 渲染播放页面的信息
        let spinCover = document.querySelector('.spin'),
            playingMusic = document.querySelector('#playing-name'),
            playingArtist = document.querySelector('#playing-artist');
        playingMusic.innerText = music.name;
        playingArtist.innerText = music.artist;
        if (music.cover) spinCover.src = music.cover;
        spinCover.style.animationPlayState = 'running';
    }

    getMusicInfo(dataId) {
        var selectedSongNode = document.querySelector(`li.song[data-id=${CSS.escape(dataId)}]`);
        if (!selectedSongNode) return null;
        return {
            id: dataId,
            name: getItem(selectedSongNode, 'data-name'),
            artist: getItem(selectedSongNode ,'data-artist'),
            cover: getItem(selectedSongNode, 'data-cover'),
            file: getItem(selectedSongNode, 'data-file')
        };
    }

    getMusicNodeInfo(node) {
        var id = node.dataset['id'];
        return this.getMusicInfo(id);
    }

    next(mode="loop", prev=false) {
        var _prevMusicNode = this.currentMusicNode;
        var spinCover = document.querySelector('.spin');
        spinCover.style.animationPlayState = 'paused';
        this.audio.pause();
        // 这原本应该是从服务器获取的,这里简化一下就直接从 DOM 上获取了,并且因此放弃随机播放功能
        if (!prev) {
            let nextSongNode = this.currentMusicNode.nextElementSibling,
                nextMusic;
            if (!nextSongNode) nextSongNode = this.firstMusicNode;
            this.currentMusicNode.classList.remove('active');
            nextSongNode.classList.add('active');
            nextMusic = this.getMusicNodeInfo(nextSongNode);
            this.select(nextMusic);

        } else {
            if (!this.prevMusicNode) {
                console.log("You didn't play any music before");
                return;
            }

            let prevMusic = this.getMusicNodeInfo(this.prevMusicNode);
            this.select(prevMusic);
        }
        this.prevMusicNode = _prevMusicNode;
        this.play();
    }
}

var mplayer = new ExtendedMusicPlayer();

function main() {
    clickHijack();
    // 针对滚动条影响居中对齐问题,动态修改样式
    window.addEventListener('resize', function() {
        var style = document.getElementById("altered-css"),
            main = document.querySelector('main');
        if (style) {
            style.parentNode.removeChild(style);
        }
        style = document.createElement('style');
        style.type = 'text/css';
        style.id = "altered-css";
        style.innerHTML = `.song {margin-left: ${getScrollbarWidth(main)}px`;
        document.head.appendChild(style);
    }, false);

    // 主区域滚动事件处理
    let main = document.querySelector('main'),
        scrollFn = throttle(
            function () {
                let statusBar = document.querySelector('.status-bar');
                if (main.scrollTop + main.clientHeight == main.scrollHeight)
                {
                    fetch(musicHost + `/music/list/${lastMusicId}/limit/5`,
                          {mode: 'cors'})
                        .then(response => {
                            return response.json();
                        })
                        .then(data => {
                            if (data.playlist.length == 0) {
                                // do nothing

                                statusBar.innerHTML = `<p>当前已加载歌曲共${playlistRender.amount}首, 已经完全加载完毕</p>`;
                                statusBar.animate([
                                    {
                                        opacity: 0
                                    },
                                    {
                                        opacity: 1
                                    },
                                    {
                                        opacity: 0
                                    }
                                ], {duration: 5000});
                                statusBar.style.opacity = 0;

                            } else {
                                playlistRender("#music-content", data);
                            }
                        });
                } else if (main.scrollTop == 0) {
                    statusBar.animate([
                        {
                            opacity: 0
                        },
                        {
                            opacity: 1
                        },
                        {
                            opacity: 0
                        }
                    ], {duration: 5000});
                    statusBar.style.opacity = 0;
                }
            }, 500, 1000);

    if (!main.onscroll)
        main.addEventListener('scroll', scrollFn, false);

    // 主页: 渲染列表
    fetch(
        musicHost + `/music/list/${lastMusicId}/limit/5`,
        {mode: 'cors'})
        .then(response => response.json())
        .then(data => {
            playlistRender('#music-content', data);
        });

    // 播放页面: 绑定播放器控件
    var volumeControl = document.querySelector('input[name=volume]'),

        progressControl = document.querySelector('input[name=progress]'),

        btnPlayPrev = document.querySelector('img.prev'),

        btnPlayNext = document.querySelector('img.next');

    mplayer.bindingUI(volumeControl, 'input', function(event) {
        mplayer.setVolume(event.target.value);
    });

    mplayer.bindingUI(progressControl, 'input', function(event) {
        mplayer.setProgress(event.target.value);
    });

    mplayer.bindingUI(btnPlayPrev, 'click', () => mplayer.next('loop', true));

    mplayer.bindingUI(btnPlayNext, 'click', () => mplayer.next('loop', false));
}

// 切换首页和歌曲播放页
var togglePage = (function() {
    let isIndex = true,
        delay = 200,
        pageIndex = document.querySelector('#index-page'),
        pagePlaying = document.querySelector('#playing-page'),
        transformLeft = function() {
            setTimeout(function() {
                pageIndex.classList.add('hidden');
                pagePlaying.classList.remove('hidden');
            }, delay);
            pageIndex.animate([
                {
                    transform: 'translateX(0)'
                },
                {
                    transform: 'translateX(-100%)'
                }
            ], {
                duration: delay,
            });
        },
        transformRight = function() {
            setTimeout(function() {
                pageIndex.classList.remove('hidden');
                pagePlaying.classList.add('hidden');
            }, delay);
            pagePlaying.animate([
                {
                    transform: 'translateX(0)'
                },
                {
                    transform: 'translateX(100%)'
                }
            ], {
                duration: delay
            });
        };


    return function() {
        if (isIndex) {
            transformLeft();
        } else {
            transformRight();
        }
        isIndex = !isIndex;
    };
})();

// 拦截部分元素的点击事件
function clickHijack() {
    document.onclick = function(event) {
        event = event || window.event;
        var target = event.target || event.srcElement;
        if (target.onclick) return target.onclick(event);
        if (target.tagName == 'LI' && target.className == 'btn-link') {
            target.onclick = clickBtn(target);
        }
        else if (target.tagName == 'IMG' && target.classList.contains('mcover')) {
            target.onclick = playingBtn(target);
        }
        else if (target.tagName == 'I' && target.classList.contains('icon-back')) {
            togglePage();
        }
        else if (target.className == 'pause') {
            let spinCover = document.querySelector('.spin');
            spinCover.style.animationPlayState = 'paused';
            mplayer.pause();
            target.classList.add('hidden');
            target.nextElementSibling.classList.remove('hidden');
        }
        else if (target.className == 'play') {
            let spinCover = document.querySelector('.spin');
            spinCover.style.animationPlayState = 'running';
            mplayer.play();
            target.classList.add('hidden');
            target.previousElementSibling.classList.remove('hidden');

        }
        else if (target.tagName == 'INPUT' &&
                 target.attributes.getNamedItem('name').value == 'progress') {
            target.onclick = function(event) {
                event.cancelBubble = true;
                mplayer.setProgress(target.value);
            };
        }
        else if (target.tagName == 'I' && target.classList.contains('icon-like')) {
            let music = mplayer.getMusicNodeInfo(target.parentNode.parentNode);
            console.log(music);
            // TODO: 给 liked 的曲添加样式
            MusicManager.addOrRemove(
                music,
                function () {
                    target.classList.add('liked');
                    console.log('adding');
                },
                function () {
                    target.classList.remove('liked');
                    console.log('removing');
                });
        }
        target.onclick && target.onclick(event);
    };
}

// 点击首页的三个按钮
// 歌曲列表 按钮从网络加载数据
// 我的最爱 按钮从 localstorage 加载数据
//
var clickBtn = (function() {
    let prevId = 'music',
        musicListData,
        divFav = document.querySelector('.fav'),
        divRes= document.querySelector('.result'),
        divMusic = document.querySelector('.music');
    return function(target){
        return function(event) {
            event.cancelBubble = true;
            let id = target.id; //target.attributes.getNamedItem('id').value;
            if (!target.classList.contains('active')) {
                target.classList.add('active');
                // 从 localstorage 加载用户的收藏曲目
                switch(id) {
                case 'music':
                    divMusic.classList.remove('hidden');
                    divFav.classList.add('hidden');
                    divRes.classList.add('hidden');
                    break;
                case 'fav':
                    divMusic.classList.add('hidden');
                    divFav.classList.remove('hidden');
                    divRes.classList.add('hidden');
                    playlistRender("#fav-content", { playlist: MusicManager.getFavMusic() }, false);
                    break;
                case 'result':
                    divMusic.classList.add('hidden');
                    divFav.classList.add('hidden');
                    divRes.classList.remove('hidden');
                    break;
                default:
                    console.error('An error has been raised');
                }
            }
            if (prevId && prevId != id) {
                let prevBtn = document.getElementById(prevId);
                prevBtn.classList.remove('active');
            }
            prevId = target.id;
        };
    };
})();

var playingBtn = (function() {
    let prevOne;

    return function (target) {
        return function(event) {
            event.cancelBubble = true;
            if (!prevOne || !target.parentNode.parentNode.classList.contains('active')) {
                // 第一次播放或者切换播放
                if (prevOne) {
                    prevOne.parentNode.parentNode.classList.remove('active');
                }
                let spinCover = document.querySelector('.spin'),
                    music = mplayer.getMusicNodeInfo(target.parentNode.parentNode);
                prevOne = target;
                // target.parentNode.parentNode.classList.add('active');
                togglePage();
                mplayer.select(music);
                mplayer.play();
            } else {
                // 点击当前播放的歌曲,直接切换页面
                togglePage();
            }
        }
    };
})();

// 列表渲染,有两种模式,第一种是 append,也就是在原有歌曲列表中插入数据,主要用于渲染 歌曲列表 按钮的结果,以及实现下拉加载功能
// 第二种模式是重新渲染列表主要用于 我的最爱 按钮的结果,目前只考虑到小量的歌曲,所以直接重新加载
var playlistRender = (function(){
    let tplSong = document.querySelector('#song-template').innerText;

    var resFunc = function(rule, data={ playlist: [] }, append=true) {
        let listContent = document.querySelector(rule),
            main = document.querySelector('main'),
            statusBar = document.querySelector(`section[data-tag=${rule.substr(1)}]`),
            statusBarHandler = function () {
                fetch(musicHost + `/music/list/${resFunc.amount}/limit/5`, {mode: 'cors'})
                    .then(response => {
                        return response.json();
                    })
                    .then(data => {
                        if (data.playlist.length == 0) {
                            let statusBar = document.querySelector('.status-bar');
                            statusBar.innerHTML = `<p>当前已加载歌曲共${resFunc.amount}首, 已经完全加载完毕</p>`;
                        } else {
                            playlistRender(rule, data);
                        }
                    });
            },
            rendered;
        data.playlist.forEach(function(obj) {
            if (!obj.file.startsWith(musicHost))
                obj.file = musicHost + obj.file;
            if (!obj.cover.startsWith(musicHost))
                obj.cover = musicHost + obj.cover;
        });
        rendered = Mustache.render(tplSong, data);
        if (append) {
            if (0 < data.playlist.length) {
                lastMusicId = data.playlist[data.playlist.length-1].id;
            }
            resFunc.amount += data.playlist.length;
            let amount = resFunc.amount;
            listContent.insertAdjacentHTML('beforeend', rendered);
            statusBar.innerHTML = `<p>当前已加载歌曲共${amount}首</p>`;
            if (!isScrollable(main)) {
                statusBar.innerHTML = `<p>当前已加载歌曲共${amount}首,可以尝试点击这里刷新</p>`;
                if (!statusBar.onclick)
                    statusBar.addEventListener('click', statusBarHandler, false);
            } else {
                statusBar.removeEventListener('click', statusBarHandler, false);
                var style = document.getElementById("altered-css");
                if (style) {
                    style.parentNode.removeChild(style);
                }
                style = document.createElement('style');
                style.type = 'text/css';
                style.id = "altered-css";
                style.innerHTML = `.song {margin-left: ${getScrollbarWidth(main)}px`;
                document.head.appendChild(style);
            }
        } else {
            listContent.innerHTML = rendered;
            statusBar.innerHTML = "<p>当前收藏歌曲共" + data.playlist.length + "首</p>";
        }
    };
    resFunc.amount = 0;
    return resFunc;
})();

main();
